<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Document Scanner</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #f0f4f8;
            --text-color: #333;
            --border-color: #ddd;
            --background-color: #ffffff;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: var(--secondary-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        .container {
            width: 100%;
            max-width: 900px;
            background-color: var(--background-color);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        header {
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 20px;
            margin-bottom: 20px;
        }
        header h1 {
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }
        #main-app h2 {
            color: #555;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }
        .file-label {
            display: inline-block;
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .file-label:hover { background-color: #0056b3; }
        #file-input { display: none; }
        .canvas-wrapper, .preview-wrapper {
            position: relative;
            border: 2px dashed var(--border-color);
            background-color: #f9f9f9;
            padding: 5px;
            max-width: 100%;
            margin: 0 auto;
            touch-action: none;
        }
        #canvas {
            display: block;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        #preview-image {
            display: block;
            max-width: 100%;
            height: auto;
            margin: 0 auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .controls {
            margin-top: 20px;
            padding: 15px;
            background: #f9f9fa;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }
        .controls h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: #555;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }
        .controls button {
            padding: 10px 15px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            transition: all 0.2s;
        }
        .controls button:hover { background-color: #e9ecef; border-color: #aaa; }
        .controls button:active { background-color: #dde2e6; }
        .action-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            font-size: 1.1em;
            font-weight: bold;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .action-button:hover { background-color: #218838; }
        .download-button {
            text-decoration: none;
            text-align: center;
            box-sizing: border-box;
        }
        #quality-slider {
            width: 100%;
            margin-top: 5px;
        }
        .hidden { display: none !important; }
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid var(--primary-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        #loader p {
            margin-top: 20px;
            font-size: 1.2em;
            color: var(--primary-color);
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>

</head>
<body>

    <div class="container">
        <header>
            <h1>Advanced Document Scanner</h1>
            <p>A non-destructive, web-based tool to crop and enhance your documents.</p>
        </header>

        <div id="main-app">
            <div class="uploader-section">
                <label for="file-input" class="file-label">1. Upload Image</label>
                <input type="file" id="file-input" accept="image/*">
            </div>

            <div id="editor-container" class="hidden">
                <h2>2. Adjust Crop Area</h2>
                <div class="controls">
                    <label>
                        <input type="checkbox" id="rectangular-mode-toggle"> Rectangular crop mode
                    </label>
                </div>
                <div class="canvas-wrapper"><canvas id="canvas"></canvas></div>
                <button id="crop-button" class="action-button">Apply Crop & Preview Below Â»</button>
            </div>

            <div id="enhancement-container" class="hidden">
                <h2>3. Enhance & Download</h2>
                <div class="preview-wrapper"><img id="preview-image" alt="Cropped Document Preview"></div>
                <div class="controls">
                    <h3>Enhancements</h3>
                    <button id="enhance-button">B&W Document</button>
                    <button id="grayscale-button">Grayscale</button>
                    <button id="original-color-button">Original Color</button>
                </div>
                <div class="controls">
                    <h3>Download Options</h3>
                    <label for="quality-slider">JPEG Quality: <span id="quality-value">92</span>%</label>
                    <input type="range" id="quality-slider" min="10" max="100" value="92" step="1">
                    <a id="download-link" class="action-button download-button">Download Image</a>
                </div>
            </div>
        </div>

        <div id="loader"><div class="spinner"></div><p>Processing...</p></div>
    </div>

    <script>
        let appReady = true;
        let cropper;
        let originalImage = null;
        let originalCroppedCanvas;
        let processedCanvas;

        const MAX_PREVIEW_DIMENSION = 1000;

        const ui = {
            fileInput: document.getElementById('file-input'),
            editorContainer: document.getElementById('editor-container'),
            enhancementContainer: document.getElementById('enhancement-container'),
            canvas: document.getElementById('canvas'),
            ctx: document.getElementById('canvas').getContext('2d'),
            cropButton: document.getElementById('crop-button'),
            rectangularModeToggle: document.getElementById('rectangular-mode-toggle'),
            previewImage: document.getElementById('preview-image'),
            enhanceButton: document.getElementById('enhance-button'),
            grayscaleButton: document.getElementById('grayscale-button'),
            originalColorButton: document.getElementById('original-color-button'),
            qualitySlider: document.getElementById('quality-slider'),
            qualityValue: document.getElementById('quality-value'),
            downloadLink: document.getElementById('download-link'),
            loader: document.getElementById('loader')
        };

        const loader = {
            show: (text) => {
                ui.loader.querySelector('p').textContent = text || 'Processing...';
                ui.loader.classList.remove('hidden');
            },
            hide: () => ui.loader.classList.add('hidden')
        };

        setTimeout(() => loader.hide(), 100);

        class ImageProcessor {
            static createCanvas(width, height) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            }

            static getImageData(canvas) {
                const ctx = canvas.getContext('2d');
                return ctx.getImageData(0, 0, canvas.width, canvas.height);
            }

            static putImageData(canvas, imageData) {
                const ctx = canvas.getContext('2d');
                ctx.putImageData(imageData, 0, 0);
            }

            static imageToCanvas(image) {
                const canvas = this.createCanvas(image.width, image.height);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(image, 0, 0);
                return canvas;
            }

            static perspectiveTransform(srcCanvas, corners, destWidth, destHeight) {
                const srcCtx = srcCanvas.getContext('2d');
                const srcImageData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);

                const destCanvas = this.createCanvas(destWidth, destHeight);
                const destCtx = destCanvas.getContext('2d');
                const destImageData = destCtx.createImageData(destWidth, destHeight);

                const [x0, y0, x1, y1, x2, y2, x3, y3] = corners;

                const dwMinus1 = destWidth - 1;
                const dhMinus1 = destHeight - 1;

                for (let y = 0; y < destHeight; y++) {
                    for (let x = 0; x < destWidth; x++) {
                        const u = (dwMinus1 === 0) ? 0 : x / dwMinus1;
                        const v = (dhMinus1 === 0) ? 0 : y / dhMinus1;

                        const oneMinusU = 1 - u;
                        const oneMinusV = 1 - v;

                        const srcX = oneMinusU * oneMinusV * x0 + u * oneMinusV * x1 + u * v * x2 + oneMinusU * v * x3;
                        const srcY = oneMinusU * oneMinusV * y0 + u * oneMinusV * y1 + u * v * y2 + oneMinusU * v * y3;

                        const sample = this.bilinearSample(srcImageData, srcX, srcY);

                        const destIndex = (y * destWidth + x) * 4;
                        destImageData.data[destIndex] = sample.r;
                        destImageData.data[destIndex + 1] = sample.g;
                        destImageData.data[destIndex + 2] = sample.b;
                        destImageData.data[destIndex + 3] = sample.a;
                    }
                }

                destCtx.putImageData(destImageData, 0, 0);
                return destCanvas;
            }

            static bilinearSample(imageData, x, y) {
                const width = imageData.width;
                const height = imageData.height;
                const data = imageData.data;

                const xClamped = Math.max(0, Math.min(x, width - 1));
                const yClamped = Math.max(0, Math.min(y, height - 1));

                const x0 = Math.floor(xClamped);
                const y0 = Math.floor(yClamped);
                const x1 = Math.min(x0 + 1, width - 1);
                const y1 = Math.min(y0 + 1, height - 1);

                const dx = xClamped - x0;
                const dy = yClamped - y0;

                const oneMinusDx = 1 - dx;
                const oneMinusDy = 1 - dy;

                const index00 = (y0 * width + x0) * 4;
                const index10 = (y0 * width + x1) * 4;
                const index01 = (y1 * width + x0) * 4;
                const index11 = (y1 * width + x1) * 4;

                const r = Math.round(
                    oneMinusDx * oneMinusDy * data[index00]     + dx * oneMinusDy * data[index10]     +
                    oneMinusDx * dy       * data[index01]     + dx * dy       * data[index11]
                );
                const g = Math.round(
                    oneMinusDx * oneMinusDy * data[index00 + 1] + dx * oneMinusDy * data[index10 + 1] +
                    oneMinusDx * dy       * data[index01 + 1] + dx * dy       * data[index11 + 1]
                );
                const b = Math.round(
                    oneMinusDx * oneMinusDy * data[index00 + 2] + dx * oneMinusDy * data[index10 + 2] +
                    oneMinusDx * dy       * data[index01 + 2] + dx * dy       * data[index11 + 2]
                );
                const a = Math.round(
                    oneMinusDx * oneMinusDy * data[index00 + 3] + dx * oneMinusDy * data[index10 + 3] +
                    oneMinusDx * dy       * data[index01 + 3] + dx * dy       * data[index11 + 3]
                );

                return { r, g, b, a };
            }

            static toGrayscale(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                }

                const resultCanvas = this.createCanvas(canvas.width, canvas.height);
                const resultCtx = resultCanvas.getContext('2d');
                resultCtx.putImageData(imageData, 0, 0);
                return resultCanvas;
            }

            static bilateralFilter(canvas, d = 9, sigmaColor = 75, sigmaSpace = 75) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;

                const resultData = new Uint8ClampedArray(data.length);
                const radius = Math.floor(d / 2);

                const twoSigmaSpaceSq = 2 * sigmaSpace * sigmaSpace;
                const twoSigmaColorSq = 2 * sigmaColor * sigmaColor;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let totalWeight = 0;
                        let sumR = 0, sumG = 0, sumB = 0;

                        const centerIndex = (y * width + x) * 4;
                        const centerR = data[centerIndex];
                        const centerG = data[centerIndex + 1];
                        const centerB = data[centerIndex + 2];

                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;

                                if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                    const neighborIndex = (ny * width + nx) * 4;
                                    const neighborR = data[neighborIndex];
                                    const neighborG = data[neighborIndex + 1];
                                    const neighborB = data[neighborIndex + 2];

                                    const spatialDistSq = dx * dx + dy * dy;
                                    const spatialWeight = Math.exp(-spatialDistSq / twoSigmaSpaceSq);

                                    const colorDistSq =
                                        (centerR - neighborR) * (centerR - neighborR) +
                                        (centerG - neighborG) * (centerG - neighborG) +
                                        (centerB - neighborB) * (centerB - neighborB);
                                    const colorWeight = Math.exp(-colorDistSq / twoSigmaColorSq);

                                    const weight = spatialWeight * colorWeight;
                                    totalWeight += weight;

                                    sumR += neighborR * weight;
                                    sumG += neighborG * weight;
                                    sumB += neighborB * weight;
                                }
                            }
                        }
                        if (totalWeight === 0) {
                            resultData[centerIndex]     = centerR;
                            resultData[centerIndex + 1] = centerG;
                            resultData[centerIndex + 2] = centerB;
                        } else {
                            resultData[centerIndex]     = sumR / totalWeight;
                            resultData[centerIndex + 1] = sumG / totalWeight;
                            resultData[centerIndex + 2] = sumB / totalWeight;
                        }
                        resultData[centerIndex + 3] = data[centerIndex + 3];
                    }
                }

                const resultCanvas = this.createCanvas(width, height);
                const resultCtx = resultCanvas.getContext('2d');
                const resultImageData = new ImageData(resultData, width, height);
                resultCtx.putImageData(resultImageData, 0, 0);
                return resultCanvas;
            }

            static adaptiveThreshold(canvas, blockSize = 15, C = 8) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;

                const result = new Uint8ClampedArray(data.length);
                const radius = Math.floor(blockSize / 2);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let sum = 0;
                        let count = 0;

                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;

                                if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                    const index = (ny * width + nx) * 4;
                                    const gray = Math.round(0.299 * data[index] + 0.587 * data[index + 1] + 0.114 * data[index + 2]);
                                    sum += gray;
                                    count++;
                                }
                            }
                        }

                        const mean = sum / count;
                        const centerIndex = (y * width + x) * 4;
                        const centerGray = Math.round(0.299 * data[centerIndex] + 0.587 * data[centerIndex + 1] + 0.114 * data[centerIndex + 2]);

                        const threshold = mean - C;
                        const value = centerGray > threshold ? 255 : 0;

                        result[centerIndex] = value;
                        result[centerIndex + 1] = value;
                        result[centerIndex + 2] = value;
                        result[centerIndex + 3] = 255;
                    }
                }

                const resultCanvas = this.createCanvas(width, height);
                const resultCtx = resultCanvas.getContext('2d');
                const resultImageData = new ImageData(result, width, height);
                resultCtx.putImageData(resultImageData, 0, 0);
                return resultCanvas;
            }

            static calculateMean(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                let sum = 0;
                let count = 0;

                for (let i = 0; i < data.length; i += 4) {
                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                    sum += gray;
                    count++;
                }

                return sum / count;
            }

            static invert(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }

                const resultCanvas = this.createCanvas(canvas.width, canvas.height);
                const resultCtx = resultCanvas.getContext('2d');
                resultCtx.putImageData(imageData, 0, 0);
                return resultCanvas;
            }
        }

        class PerspectiveCropper {
            constructor(canvas, ctx, previewImage, fullResImage) {
                Object.assign(this, { canvas, ctx, image: previewImage, originalImage: fullResImage });
                this.handles = [];
                this.handleRadius = 12;
                this.handleHitRadius = 30;
                this.sideHitRadius = 15;
                this.isDragging = false;
                this.draggedHandleIndex = null;
                this.draggedSideIndex = null;
                this.isDraggingSide = false;
                this.isRectangularMode = false;
                this.isDraggingCropArea = false;

                this.canvasRect = null;
                this.canvasScaleX = 1;
                this.canvasScaleY = 1;

                this.init();
            }

            updateCanvasCache() {
                this.canvasRect = this.canvas.getBoundingClientRect();
                this.canvasScaleX = this.canvas.width / this.canvasRect.width;
                this.canvasScaleY = this.canvas.height / this.canvasRect.height;
            }

            init() {
                this.setCanvasSize();
                this.initHandles();
                this.addEventListeners();
                setTimeout(() => this.updateCanvasCache(), 0);
                this.draw();
            }

            setRectangularMode(enabled) {
                this.isRectangularMode = enabled;
                if (enabled) {
                    this.makeRectangular();
                }
                this.draw();
            }

            makeRectangular() {
                const w = this.canvas.width;
                const h = this.canvas.height;

                const centerX = this.handles.reduce((sum, h) => sum + h.x, 0) / 4;
                const centerY = this.handles.reduce((sum, h) => sum + h.y, 0) / 4;

                const avgWidth = Math.max(
                    Math.abs(this.handles[1].x - this.handles[0].x),
                    Math.abs(this.handles[2].x - this.handles[3].x)
                );
                const avgHeight = Math.max(
                    Math.abs(this.handles[2].y - this.handles[1].y),
                    Math.abs(this.handles[3].y - this.handles[0].y)
                );

                const halfWidth = Math.min(avgWidth / 2, w / 2);
                const halfHeight = Math.min(avgHeight / 2, h / 2);

                this.handles[0] = { x: Math.max(0, centerX - halfWidth), y: Math.max(0, centerY - halfHeight) };
                this.handles[1] = { x: Math.min(w - 1, centerX + halfWidth), y: Math.max(0, centerY - halfHeight) };
                this.handles[2] = { x: Math.min(w - 1, centerX + halfWidth), y: Math.min(h - 1, centerY + halfHeight) };
                this.handles[3] = { x: Math.max(0, centerX - halfWidth), y: Math.min(h - 1, centerY + halfHeight) };
            }

            setCanvasSize() {
                const scale = (ui.editorContainer.clientWidth - 10) / this.image.width;
                this.canvas.width = this.image.width;
                this.canvas.height = this.image.height;
                this.canvas.style.width = `${this.image.width * scale}px`;
                this.canvas.style.height = `${this.image.height * scale}px`;
            }

            initHandles() {
                const w = this.canvas.width;
                const h = this.canvas.height;
                this.handles = [{ x: 0, y: 0 }, { x: w - 1, y: 0 }, { x: w - 1, y: h - 1 }, { x: 0, y: h - 1 }];
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.image, 0, 0, this.canvas.width, this.canvas.height);
                this.ctx.beginPath();
                this.ctx.moveTo(this.handles[0].x, this.handles[0].y);
                this.handles.slice(1).forEach(h => this.ctx.lineTo(h.x, h.y));
                this.ctx.closePath();
                this.ctx.fillStyle = 'rgba(0, 123, 255, 0.3)';
                this.ctx.strokeStyle = 'rgba(0, 123, 255, 1)';
                this.ctx.lineWidth = 2;
                this.ctx.fill();
                this.ctx.stroke();

                this.handles.forEach(h => {
                    this.ctx.beginPath();
                    this.ctx.arc(h.x, h.y, this.handleRadius, 0, 2 * Math.PI);
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    this.ctx.strokeStyle = 'rgba(0, 123, 255, 1)';
                    this.ctx.lineWidth = 3;
                    this.ctx.fill();
                    this.ctx.stroke();
                });
            }

            getHandleAt(pos) {
                for (let i = 0; i < this.handles.length; i++) {
                    if (Math.hypot(this.handles[i].x - pos.x, this.handles[i].y - pos.y) <= this.handleHitRadius) return i;
                }
                return null;
            }

            getSideAt(pos) {
                const sides = [
                    [this.handles[0], this.handles[1]],
                    [this.handles[1], this.handles[2]],
                    [this.handles[2], this.handles[3]],
                    [this.handles[3], this.handles[0]]
                ];

                for (let i = 0; i < sides.length; i++) {
                    const [p1, p2] = sides[i];
                    const distance = this.pointToLineDistance(pos, p1, p2);

                    if (distance <= this.sideHitRadius) {
                        const minX = Math.min(p1.x, p2.x) - this.sideHitRadius;
                        const maxX = Math.max(p1.x, p2.x) + this.sideHitRadius;
                        const minY = Math.min(p1.y, p2.y) - this.sideHitRadius;
                        const maxY = Math.max(p1.y, p2.y) + this.sideHitRadius;

                        if (pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY) {
                            return i;
                        }
                    }
                }
                return null;
            }

            isInsideCropArea(pos) {
                let inside = false;
                const vertices = this.handles;

                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    if (((vertices[i].y > pos.y) !== (vertices[j].y > pos.y)) &&
                        (pos.x < (vertices[j].x - vertices[i].x) * (pos.y - vertices[i].y) / (vertices[j].y - vertices[i].y) + vertices[i].x)) {
                        inside = !inside;
                    }
                }
                return inside;
            }

            pointToLineDistance(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;

                let xx, yy;
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }

                return Math.hypot(point.x - xx, point.y - yy);
            }

            getEventPosition(event) {
                if (!this.canvasRect) {
                    this.updateCanvasCache();
                }
                const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                return {
                    x: (clientX - this.canvasRect.left) * this.canvasScaleX,
                    y: (clientY - this.canvasRect.top) * this.canvasScaleY
                };
            }

            addEventListeners() {
                const events = ['mousedown', 'mousemove', 'mouseup', 'mouseleave', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];

                this.boundOnDragStart = this.onDragStart.bind(this);
                this.boundOnDragMove = this.onDragMove.bind(this);
                this.boundOnDragEnd = this.onDragEnd.bind(this);

                const handlerMap = {
                    start: this.boundOnDragStart,
                    move: this.boundOnDragMove,
                    end: this.boundOnDragEnd
                };
                events.forEach(e => {
                    if (e.includes('start')) this.canvas.addEventListener(e, handlerMap.start);
                    if (e.includes('move')) this.canvas.addEventListener(e, handlerMap.move);
                    if (e.includes('end') || e.includes('up') || e.includes('leave') || e.includes('cancel')) this.canvas.addEventListener(e, handlerMap.end);
                });
            }

            onDragStart(e) {
                if (e.cancelable) e.preventDefault();
                this.updateCanvasCache();
                const pos = this.getEventPosition(e);

                const handleIndex = this.getHandleAt(pos);
                if (handleIndex !== null) {
                    this.isDragging = true;
                    this.draggedHandleIndex = handleIndex;
                    this.isDraggingSide = false;
                    this.isDraggingCropArea = false;
                    return;
                }

                const sideIndex = this.getSideAt(pos);
                if (sideIndex !== null) {
                    this.isDragging = true;
                    this.isDraggingSide = true;
                    this.isDraggingCropArea = false;
                    this.draggedSideIndex = sideIndex;
                    this.sideStartPos = pos;
                    return;
                }

                if (this.isInsideCropArea(pos)) {
                    this.isDragging = true;
                    this.isDraggingSide = false;
                    this.isDraggingCropArea = true;
                    this.cropAreaStartPos = pos;
                }
            }

            onDragMove(e) {
                if (e.cancelable) e.preventDefault();
                if (!this.isDragging) return;

                const pos = this.getEventPosition(e);

                if (this.isDraggingCropArea) {
                    this.moveCropArea(pos);
                } else if (this.isDraggingSide) {
                    this.moveSide(pos);
                } else {
                    this.moveHandle(pos);
                }

                this.draw();
            }

            moveCropArea(pos) {
                const deltaX = pos.x - this.cropAreaStartPos.x;
                const deltaY = pos.y - this.cropAreaStartPos.y;

                const newHandles = this.handles.map(handle => ({
                    x: Math.max(0, Math.min(handle.x + deltaX, this.canvas.width - 1)),
                    y: Math.max(0, Math.min(handle.y + deltaY, this.canvas.height - 1))
                }));

                const allHandlesValid = newHandles.every(handle =>
                    handle.x >= 0 && handle.x < this.canvas.width &&
                    handle.y >= 0 && handle.y < this.canvas.height
                );

                if (allHandlesValid) {
                    this.handles = newHandles;
                    this.cropAreaStartPos = pos;
                }
            }

            moveHandle(pos) {
                const clampedX = Math.max(0, Math.min(pos.x, this.canvas.width - 1));
                const clampedY = Math.max(0, Math.min(pos.y, this.canvas.height - 1));

                if (this.isRectangularMode) {
                    this.moveHandleRectangular(clampedX, clampedY);
                } else {
                    this.handles[this.draggedHandleIndex].x = clampedX;
                    this.handles[this.draggedHandleIndex].y = clampedY;
                }
            }

            moveHandleRectangular(x, y) {
                const handleIndex = this.draggedHandleIndex;
                const w = this.canvas.width;
                const h = this.canvas.height;

                if (handleIndex === 0) {
                    this.handles[0] = { x, y };
                    this.handles[1].y = y;
                    this.handles[3].x = x;
                } else if (handleIndex === 1) {
                    this.handles[1] = { x, y };
                    this.handles[0].y = y;
                    this.handles[2].x = x;
                } else if (handleIndex === 2) {
                    this.handles[2] = { x, y };
                    this.handles[1].x = x;
                    this.handles[3].y = y;
                } else if (handleIndex === 3) {
                    this.handles[3] = { x, y };
                    this.handles[0].x = x;
                    this.handles[2].y = y;
                }

                this.handles.forEach(handle => {
                    handle.x = Math.max(0, Math.min(handle.x, w - 1));
                    handle.y = Math.max(0, Math.min(handle.y, h - 1));
                });
            }

            moveSide(pos) {
                const deltaX = pos.x - this.sideStartPos.x;
                const deltaY = pos.y - this.sideStartPos.y;

                if (this.isRectangularMode) {
                    this.moveSideRectangular(deltaX, deltaY);
                } else {
                    this.moveSidePerspective(deltaX, deltaY);
                }

                this.sideStartPos = pos;
            }

            moveSidePerspective(deltaX, deltaY) {
                const sideIndex = this.draggedSideIndex;
                const sides = [
                    [0, 1],
                    [1, 2],
                    [2, 3],
                    [3, 0]
                ];

                const [h1, h2] = sides[sideIndex];

                this.handles[h1].x = Math.max(0, Math.min(this.handles[h1].x + deltaX, this.canvas.width - 1));
                this.handles[h1].y = Math.max(0, Math.min(this.handles[h1].y + deltaY, this.canvas.height - 1));
                this.handles[h2].x = Math.max(0, Math.min(this.handles[h2].x + deltaX, this.canvas.width - 1));
                this.handles[h2].y = Math.max(0, Math.min(this.handles[h2].y + deltaY, this.canvas.height - 1));
            }

            moveSideRectangular(deltaX, deltaY) {
                const sideIndex = this.draggedSideIndex;
                const w = this.canvas.width;
                const h = this.canvas.height;

                if (sideIndex === 0) {
                    const newY = Math.max(0, Math.min(this.handles[0].y + deltaY, this.handles[2].y - 10));
                    this.handles[0].y = newY;
                    this.handles[1].y = newY;
                } else if (sideIndex === 1) {
                    const newX = Math.max(this.handles[0].x + 10, Math.min(this.handles[1].x + deltaX, w - 1));
                    this.handles[1].x = newX;
                    this.handles[2].x = newX;
                } else if (sideIndex === 2) {
                    const newY = Math.max(this.handles[0].y + 10, Math.min(this.handles[2].y + deltaY, h - 1));
                    this.handles[2].y = newY;
                    this.handles[3].y = newY;
                } else if (sideIndex === 3) {
                    const newX = Math.max(0, Math.min(this.handles[0].x + deltaX, this.handles[1].x - 10));
                    this.handles[0].x = newX;
                    this.handles[3].x = newX;
                }
            }

            onDragEnd() {
                this.isDragging = false;
                this.isDraggingSide = false;
                this.isDraggingCropArea = false;
                this.draggedHandleIndex = null;
                this.draggedSideIndex = null;
            }

            getCornerPoints() { return this.handles.map(h => [h.x, h.y]).flat(); }
        }

        function loadImage(file) {
            loader.show('Loading image...');
            const reader = new FileReader();
            reader.onload = e => {
                originalImage = new Image();
                originalImage.onload = () => {
                    loader.show('Preparing editor...');
                    let previewWidth = originalImage.width;
                    let previewHeight = originalImage.height;
                    let scaleFactor = 1;

                    if (previewWidth > MAX_PREVIEW_DIMENSION || previewHeight > MAX_PREVIEW_DIMENSION) {
                        if (previewWidth > previewHeight) {
                            scaleFactor = MAX_PREVIEW_DIMENSION / previewWidth;
                            previewHeight = Math.round(previewHeight * scaleFactor);
                            previewWidth = MAX_PREVIEW_DIMENSION;
                        } else {
                            scaleFactor = MAX_PREVIEW_DIMENSION / previewHeight;
                            previewWidth = Math.round(previewWidth * scaleFactor);
                            previewHeight = MAX_PREVIEW_DIMENSION;
                        }
                    }

                    const previewCanvas = document.createElement('canvas');
                    previewCanvas.width = previewWidth;
                    previewCanvas.height = previewHeight;
                    const previewCtx = previewCanvas.getContext('2d');
                    previewCtx.drawImage(originalImage, 0, 0, previewWidth, previewHeight);

                    const previewImage = new Image();
                    previewImage.onload = () => {
                        ui.editorContainer.classList.remove('hidden');
                        ui.enhancementContainer.classList.add('hidden');
                        cropper = new PerspectiveCropper(ui.canvas, ui.ctx, previewImage, originalImage);
                        ui.rectangularModeToggle.checked = false;
                        loader.hide();
                    };
                    previewImage.onerror = () => {
                        loader.hide();
                        alert("Error creating image preview.");
                    };
                    previewImage.src = previewCanvas.toDataURL();

                };
                originalImage.onerror = () => {
                    loader.hide();
                    alert("Error loading image file.");
                };
                originalImage.src = e.target.result;
            };
            reader.onerror = () => {
                loader.hide();
                alert("Error reading file.");
            };
            reader.readAsDataURL(file);
        }

        async function applyCrop() {
            if (!appReady || !cropper) return;
            loader.show('Applying crop...');

            try {
                const imageBitmap = await createImageBitmap(cropper.originalImage);

                const scaleX = cropper.originalImage.width / cropper.image.width;
                const scaleY = cropper.originalImage.height / cropper.image.height;

                const scaledHandles = cropper.handles.map(h => ({ x: h.x * scaleX, y: h.y * scaleY }));
                const [sTl, sTr, sBr, sBl] = scaledHandles;

                const destWidth = Math.round(Math.max(Math.hypot(sBr.x - sBl.x, sBr.y - sBl.y), Math.hypot(sTr.x - sTl.x, sTr.y - sTl.y)));
                const destHeight = Math.round(Math.max(Math.hypot(sTr.x - sBr.x, sTr.y - sBr.y), Math.hypot(sTl.x - sBl.x, sTl.y - sBl.y)));

                const corners = scaledHandles.map(h => [h.x, h.y]).flat();

                if (originalCroppedCanvas) originalCroppedCanvas = null;

                originalCroppedCanvas = await postTaskToWorker('perspectiveTransform', {
                    imageBitmap: imageBitmap,
                    corners: corners,
                    destWidth: destWidth,
                    destHeight: destHeight
                });

                updatePreview(originalCroppedCanvas);
                ui.enhancementContainer.classList.remove('hidden');

            } catch (error) {
                console.error("Error during applyCrop:", error);
                alert("An error occurred during crop processing: " + error.message);
            } finally {
                loader.hide();
            }
        }

        function updatePreview(canvas) {
            if (processedCanvas) processedCanvas = null;
            processedCanvas = document.createElement('canvas');
            processedCanvas.width = canvas.width;
            processedCanvas.height = canvas.height;
            const ctx = processedCanvas.getContext('2d');
            ctx.drawImage(canvas, 0, 0);

            const quality = parseFloat(ui.qualitySlider.value) / 100;
            const dataUrl = processedCanvas.toDataURL('image/jpeg', quality);
            ui.previewImage.src = dataUrl;
            ui.downloadLink.href = dataUrl;
        }

        function enhanceBAndW() {
            if (!originalCroppedCanvas) { alert("Please apply a crop first!"); return; }
            loader.show('Applying B&W enhancement...');

            setTimeout(() => {
                try {
                    let workingCanvas = originalCroppedCanvas;

                    const meanBrightness = ImageProcessor.calculateMean(workingCanvas);
                    if (meanBrightness < 120) {
                        workingCanvas = ImageProcessor.invert(workingCanvas);
                    }

                    const grayCanvas = ImageProcessor.toGrayscale(workingCanvas);

                    const blurredCanvas = ImageProcessor.bilateralFilter(grayCanvas, 9, 75, 75);

                    const enhancedCanvas = ImageProcessor.adaptiveThreshold(blurredCanvas, 15, 8);

                    updatePreview(enhancedCanvas);
                } catch (err) {
                    console.error("Error during enhancement: ", err);
                } finally {
                    loader.hide();
                }
            }, 50);
        }

        function enhanceGrayscale() {
            if (!originalCroppedCanvas) { alert("Please apply a crop first!"); return; }
            const grayCanvas = ImageProcessor.toGrayscale(originalCroppedCanvas);
            updatePreview(grayCanvas);
        }

        ui.fileInput.addEventListener('change', (e) => loadImage(e.target.files[0]));
        ui.cropButton.addEventListener('click', applyCrop);
        ui.rectangularModeToggle.addEventListener('change', (e) => {
            if (cropper) {
                cropper.setRectangularMode(e.target.checked);
            }
        });
        ui.enhanceButton.addEventListener('click', enhanceBAndW);
        ui.grayscaleButton.addEventListener('click', enhanceGrayscale);
        ui.originalColorButton.addEventListener('click', () => originalCroppedCanvas && updatePreview(originalCroppedCanvas));

        ui.qualitySlider.addEventListener('input', (e) => {
            ui.qualityValue.textContent = e.target.value;
            if (processedCanvas) updatePreview(processedCanvas);
        });

        ui.downloadLink.addEventListener('click', (e) => {
            if (!processedCanvas) {
                e.preventDefault();
                alert("Please process an image first.");
            } else {
                ui.downloadLink.download = `scanned-document-${Date.now()}.jpg`;
            }
        });

        loader.show('Initializing...');

        setTimeout(() => loader.hide(), 100);

        // --- Web Worker Setup ---
        let imageWorker;
        let workerTaskCounter = 0;
        const workerPromises = new Map();

        if (window.Worker && typeof OffscreenCanvas !== 'undefined') {
            try {
                imageWorker = new Worker('imageProcessorWorker.js');
                imageWorker.onmessage = (event) => {
                    const { id, success, imageData, error, stack } = event.data;
                    if (workerPromises.has(id)) {
                        const { resolve, reject } = workerPromises.get(id);
                        if (success) {
                            const canvas = document.createElement('canvas');
                            canvas.width = imageData.width;
                            canvas.height = imageData.height;
                            canvas.getContext('2d').putImageData(imageData, 0, 0);
                            resolve(canvas);
                        } else {
                            console.error("Worker task error:", error, stack);
                            reject(new Error("Worker task failed: " + error));
                        }
                        workerPromises.delete(id);
                    }
                };
                imageWorker.onerror = (error) => {
                    console.error("Worker global error:", error);
                    imageWorker = null;
                    alert("Image processor worker encountered an error. Performance may be degraded.");
                };
            } catch (e) {
                console.error("Failed to initialize worker:", e);
                imageWorker = null;
                alert("Could not initialize image processor worker. Performance may be degraded.");
            }
        } else {
            console.warn("Web Workers or OffscreenCanvas not supported. Image processing will run on the main thread.");
        }

        async function postTaskToWorker(taskName, workerPayload) {
            if (!imageWorker) {
                console.error("Image worker is not available.");
                return Promise.reject(new Error("Image worker not available."));
            }

            const id = workerTaskCounter++;
            const transferList = workerPayload.imageBitmap ? [workerPayload.imageBitmap] : [];

            return new Promise((resolve, reject) => {
                workerPromises.set(id, { resolve, reject });
                imageWorker.postMessage({ id, task: taskName, ...workerPayload }, transferList);
            });
        }

    </script>
</body>
</html>
