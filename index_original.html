<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Document Scanner</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #f0f4f8;
            --text-color: #333;
            --border-color: #ddd;
            --background-color: #ffffff;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: var(--secondary-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        .container {
            width: 100%;
            max-width: 900px;
            background-color: var(--background-color);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        header {
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 20px;
            margin-bottom: 20px;
        }
        header h1 {
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }
        #main-app h2 {
            color: #555;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }
        .file-label {
            display: inline-block;
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .file-label:hover { background-color: #0056b3; }
        #file-input { display: none; }
        .canvas-wrapper, .preview-wrapper {
            position: relative;
            border: 2px dashed var(--border-color);
            background-color: #f9f9f9;
            padding: 5px;
            max-width: 100%;
            margin: 0 auto;
            touch-action: none;
        }
        #canvas {
            display: block;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        #preview-image {
            display: block;
            max-width: 100%;
            height: auto;
            margin: 0 auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .controls {
            margin-top: 20px;
            padding: 15px;
            background: #f9f9fa;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }
        .controls h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: #555;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }
        .controls button {
            padding: 10px 15px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            transition: all 0.2s;
        }
        .controls button:hover { background-color: #e9ecef; border-color: #aaa; }
        .controls button:active { background-color: #dde2e6; }
        .action-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            font-size: 1.1em;
            font-weight: bold;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .action-button:hover { background-color: #218838; }
        .download-button {
            text-decoration: none;
            text-align: center;
            box-sizing: border-box;
        }
        #quality-slider {
            width: 100%;
            margin-top: 5px;
        }
        .hidden { display: none !important; }
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid var(--primary-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        #loader p {
            margin-top: 20px;
            font-size: 1.2em;
            color: var(--primary-color);
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>

</head>
<body>

    <div class="container">
        <header>
            <h1>Advanced Document Scanner</h1>
            <p>A non-destructive, web-based tool to crop and enhance your documents.</p>
        </header>

        <div id="main-app">
            <div class="uploader-section">
                <label for="file-input" class="file-label">1. Upload Image</label>
                <input type="file" id="file-input" accept="image/*">
            </div>

            <div id="editor-container" class="hidden">
                <h2>2. Adjust Crop Area</h2>
                <div class="canvas-wrapper"><canvas id="canvas"></canvas></div>
                <button id="crop-button" class="action-button">Apply Crop & Preview Below Â»</button>
            </div>

            <div id="enhancement-container" class="hidden">
                <h2>3. Enhance & Download</h2>
                <div class="preview-wrapper"><img id="preview-image" alt="Cropped Document Preview"></div>
                <div class="controls">
                    <h3>Enhancements</h3>
                    <button id="enhance-button">B&W Document</button>
                    <button id="grayscale-button">Grayscale</button>
                    <button id="original-color-button">Original Color</button>
                </div>
                <div class="controls">
                    <h3>Download Options</h3>
                    <label for="quality-slider">JPEG Quality: <span id="quality-value">92</span>%</label>
                    <input type="range" id="quality-slider" min="10" max="100" value="92" step="1">
                    <a id="download-link" class="action-button download-button">Download Image</a>
                </div>
            </div>
        </div>

        <div id="loader"><div class="spinner"></div><p>Loading OpenCV & Processing...</p></div>
    </div>
    
    <script>
        let appReady = true;
        let cropper;
        let originalCroppedCanvas;
        let processedCanvas;

        const ui = {
            fileInput: document.getElementById('file-input'),
            editorContainer: document.getElementById('editor-container'),
            enhancementContainer: document.getElementById('enhancement-container'),
            canvas: document.getElementById('canvas'),
            ctx: document.getElementById('canvas').getContext('2d'),
            cropButton: document.getElementById('crop-button'),
            previewImage: document.getElementById('preview-image'),
            enhanceButton: document.getElementById('enhance-button'),
            grayscaleButton: document.getElementById('grayscale-button'),
            originalColorButton: document.getElementById('original-color-button'),
            qualitySlider: document.getElementById('quality-slider'),
            qualityValue: document.getElementById('quality-value'),
            downloadLink: document.getElementById('download-link'),
            loader: document.getElementById('loader')
        };

        const loader = {
            show: (text) => {
                ui.loader.querySelector('p').textContent = text || 'Processing...';
                ui.loader.classList.remove('hidden');
            },
            hide: () => ui.loader.classList.add('hidden')
        };
        
        // Hide loader immediately since we don't need to load external libraries
        setTimeout(() => loader.hide(), 100);

        // Image processing utilities
        class ImageProcessor {
            static createCanvas(width, height) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            }

            static getImageData(canvas) {
                const ctx = canvas.getContext('2d');
                return ctx.getImageData(0, 0, canvas.width, canvas.height);
            }

            static putImageData(canvas, imageData) {
                const ctx = canvas.getContext('2d');
                ctx.putImageData(imageData, 0, 0);
            }

            static imageToCanvas(image) {
                const canvas = this.createCanvas(image.width, image.height);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(image, 0, 0);
                return canvas;
            }

            // Perspective transformation implementation
            static perspectiveTransform(srcCanvas, corners, destWidth, destHeight) {
                const srcCtx = srcCanvas.getContext('2d');
                const srcImageData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
                
                const destCanvas = this.createCanvas(destWidth, destHeight);
                const destCtx = destCanvas.getContext('2d');
                const destImageData = destCtx.createImageData(destWidth, destHeight);

                // Source corners (from user selection)
                const [x0, y0, x1, y1, x2, y2, x3, y3] = corners;
                
                // Destination corners (rectangle)
                const dx0 = 0, dy0 = 0;
                const dx1 = destWidth - 1, dy1 = 0;
                const dx2 = destWidth - 1, dy2 = destHeight - 1;
                const dx3 = 0, dy3 = destHeight - 1;

                // Calculate transformation matrix using bilinear interpolation
                for (let y = 0; y < destHeight; y++) {
                    for (let x = 0; x < destWidth; x++) {
                        // Normalize coordinates
                        const u = x / (destWidth - 1);
                        const v = y / (destHeight - 1);

                        // Bilinear interpolation to find source coordinates
                        const srcX = (1 - u) * (1 - v) * x0 + u * (1 - v) * x1 + u * v * x2 + (1 - u) * v * x3;
                        const srcY = (1 - u) * (1 - v) * y0 + u * (1 - v) * y1 + u * v * y2 + (1 - u) * v * y3;

                        // Bilinear sampling from source image
                        const sample = this.bilinearSample(srcImageData, srcX, srcY);
                        
                        const destIndex = (y * destWidth + x) * 4;
                        destImageData.data[destIndex] = sample.r;
                        destImageData.data[destIndex + 1] = sample.g;
                        destImageData.data[destIndex + 2] = sample.b;
                        destImageData.data[destIndex + 3] = sample.a;
                    }
                }

                destCtx.putImageData(destImageData, 0, 0);
                return destCanvas;
            }

            static bilinearSample(imageData, x, y) {
                const width = imageData.width;
                const height = imageData.height;
                const data = imageData.data;

                // Clamp coordinates
                x = Math.max(0, Math.min(x, width - 1));
                y = Math.max(0, Math.min(y, height - 1));

                const x0 = Math.floor(x);
                const y0 = Math.floor(y);
                const x1 = Math.min(x0 + 1, width - 1);
                const y1 = Math.min(y0 + 1, height - 1);

                const dx = x - x0;
                const dy = y - y0;

                const getPixel = (px, py) => {
                    const index = (py * width + px) * 4;
                    return {
                        r: data[index],
                        g: data[index + 1],
                        b: data[index + 2],
                        a: data[index + 3]
                    };
                };

                const p00 = getPixel(x0, y0);
                const p10 = getPixel(x1, y0);
                const p01 = getPixel(x0, y1);
                const p11 = getPixel(x1, y1);

                return {
                    r: Math.round((1 - dx) * (1 - dy) * p00.r + dx * (1 - dy) * p10.r + (1 - dx) * dy * p01.r + dx * dy * p11.r),
                    g: Math.round((1 - dx) * (1 - dy) * p00.g + dx * (1 - dy) * p10.g + (1 - dx) * dy * p01.g + dx * dy * p11.g),
                    b: Math.round((1 - dx) * (1 - dy) * p00.b + dx * (1 - dy) * p10.b + (1 - dx) * dy * p01.b + dx * dy * p11.b),
                    a: Math.round((1 - dx) * (1 - dy) * p00.a + dx * (1 - dy) * p10.a + (1 - dx) * dy * p01.a + dx * dy * p11.a)
                };
            }

            // Convert to grayscale
            static toGrayscale(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                    data[i] = gray;     // R
                    data[i + 1] = gray; // G
                    data[i + 2] = gray; // B
                    // Alpha channel remains unchanged
                }

                const resultCanvas = this.createCanvas(canvas.width, canvas.height);
                const resultCtx = resultCanvas.getContext('2d');
                resultCtx.putImageData(imageData, 0, 0);
                return resultCanvas;
            }

            // Simple bilateral filter approximation
            static bilateralFilter(canvas, d = 9, sigmaColor = 75, sigmaSpace = 75) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;
                
                const result = new Uint8ClampedArray(data.length);
                const radius = Math.floor(d / 2);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let totalWeight = 0;
                        let sumR = 0, sumG = 0, sumB = 0;
                        
                        const centerIndex = (y * width + x) * 4;
                        const centerR = data[centerIndex];
                        const centerG = data[centerIndex + 1];
                        const centerB = data[centerIndex + 2];
                        
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                
                                if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                    const neighborIndex = (ny * width + nx) * 4;
                                    const neighborR = data[neighborIndex];
                                    const neighborG = data[neighborIndex + 1];
                                    const neighborB = data[neighborIndex + 2];
                                    
                                    // Spatial weight
                                    const spatialDist = Math.sqrt(dx * dx + dy * dy);
                                    const spatialWeight = Math.exp(-(spatialDist * spatialDist) / (2 * sigmaSpace * sigmaSpace));
                                    
                                    // Color weight
                                    const colorDist = Math.sqrt(
                                        (centerR - neighborR) * (centerR - neighborR) +
                                        (centerG - neighborG) * (centerG - neighborG) +
                                        (centerB - neighborB) * (centerB - neighborB)
                                    );
                                    const colorWeight = Math.exp(-(colorDist * colorDist) / (2 * sigmaColor * sigmaColor));
                                    
                                    const weight = spatialWeight * colorWeight;
                                    totalWeight += weight;
                                    
                                    sumR += neighborR * weight;
                                    sumG += neighborG * weight;
                                    sumB += neighborB * weight;
                                }
                            }
                        }
                        
                        result[centerIndex] = sumR / totalWeight;
                        result[centerIndex + 1] = sumG / totalWeight;
                        result[centerIndex + 2] = sumB / totalWeight;
                        result[centerIndex + 3] = data[centerIndex + 3]; // Alpha
                    }
                }
                
                const resultCanvas = this.createCanvas(width, height);
                const resultCtx = resultCanvas.getContext('2d');
                const resultImageData = new ImageData(result, width, height);
                resultCtx.putImageData(resultImageData, 0, 0);
                return resultCanvas;
            }

            // Adaptive threshold implementation
            static adaptiveThreshold(canvas, blockSize = 15, C = 8) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;
                
                const result = new Uint8ClampedArray(data.length);
                const radius = Math.floor(blockSize / 2);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let sum = 0;
                        let count = 0;
                        
                        // Calculate local mean
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;
                                
                                if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                    const index = (ny * width + nx) * 4;
                                    const gray = Math.round(0.299 * data[index] + 0.587 * data[index + 1] + 0.114 * data[index + 2]);
                                    sum += gray;
                                    count++;
                                }
                            }
                        }
                        
                        const mean = sum / count;
                        const centerIndex = (y * width + x) * 4;
                        const centerGray = Math.round(0.299 * data[centerIndex] + 0.587 * data[centerIndex + 1] + 0.114 * data[centerIndex + 2]);
                        
                        const threshold = mean - C;
                        const value = centerGray > threshold ? 255 : 0;
                        
                        result[centerIndex] = value;
                        result[centerIndex + 1] = value;
                        result[centerIndex + 2] = value;
                        result[centerIndex + 3] = 255; // Alpha
                    }
                }
                
                const resultCanvas = this.createCanvas(width, height);
                const resultCtx = resultCanvas.getContext('2d');
                const resultImageData = new ImageData(result, width, height);
                resultCtx.putImageData(resultImageData, 0, 0);
                return resultCanvas;
            }

            // Calculate mean brightness of image
            static calculateMean(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                let sum = 0;
                let count = 0;

                for (let i = 0; i < data.length; i += 4) {
                    const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                    sum += gray;
                    count++;
                }

                return sum / count;
            }

            // Invert image colors
            static invert(canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];         // R
                    data[i + 1] = 255 - data[i + 1]; // G
                    data[i + 2] = 255 - data[i + 2]; // B
                    // Alpha channel remains unchanged
                }

                const resultCanvas = this.createCanvas(canvas.width, canvas.height);
                const resultCtx = resultCanvas.getContext('2d');
                resultCtx.putImageData(imageData, 0, 0);
                return resultCanvas;
            }
        }

        class PerspectiveCropper {
            constructor(canvas, ctx, image) {
                Object.assign(this, { canvas, ctx, image });
                this.handles = [];
                this.handleRadius = 12;
                this.handleHitRadius = 30;
                this.isDragging = false;
                this.draggedHandleIndex = null;
                this.init();
            }

            init() {
                this.setCanvasSize();
                this.initHandles();
                this.addEventListeners();
                this.draw();
            }

            setCanvasSize() {
                const scale = (ui.editorContainer.clientWidth - 10) / this.image.width;
                this.canvas.width = this.image.width;
                this.canvas.height = this.image.height;
                this.canvas.style.width = `${this.image.width * scale}px`;
                this.canvas.style.height = `${this.image.height * scale}px`;
            }

            initHandles() {
                const w = this.canvas.width;
                const h = this.canvas.height;
                this.handles = [{ x: 0, y: 0 }, { x: w - 1, y: 0 }, { x: w - 1, y: h - 1 }, { x: 0, y: h - 1 }];
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.image, 0, 0, this.canvas.width, this.canvas.height);
                this.ctx.beginPath();
                this.ctx.moveTo(this.handles[0].x, this.handles[0].y);
                this.handles.slice(1).forEach(h => this.ctx.lineTo(h.x, h.y));
                this.ctx.closePath();
                this.ctx.fillStyle = 'rgba(0, 123, 255, 0.3)';
                this.ctx.strokeStyle = 'rgba(0, 123, 255, 1)';
                this.ctx.lineWidth = 2;
                this.ctx.fill();
                this.ctx.stroke();

                this.handles.forEach(h => {
                    this.ctx.beginPath();
                    this.ctx.arc(h.x, h.y, this.handleRadius, 0, 2 * Math.PI);
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    this.ctx.strokeStyle = 'rgba(0, 123, 255, 1)';
                    this.ctx.lineWidth = 3;
                    this.ctx.fill();
                    this.ctx.stroke();
                });
            }

            getHandleAt(pos) {
                for (let i = 0; i < this.handles.length; i++) {
                    if (Math.hypot(this.handles[i].x - pos.x, this.handles[i].y - pos.y) <= this.handleHitRadius) return i;
                }
                return null;
            }

            getEventPosition(event) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            }

            addEventListeners() {
                const events = ['mousedown', 'mousemove', 'mouseup', 'mouseleave', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];
                const handlerMap = {
                    start: this.onDragStart.bind(this),
                    move: this.onDragMove.bind(this),
                    end: this.onDragEnd.bind(this)
                };
                events.forEach(e => {
                    if (e.includes('start')) this.canvas.addEventListener(e, handlerMap.start);
                    if (e.includes('move')) this.canvas.addEventListener(e, handlerMap.move);
                    if (e.includes('end') || e.includes('up') || e.includes('leave') || e.includes('cancel')) this.canvas.addEventListener(e, handlerMap.end);
                });
            }

            onDragStart(e) {
                if (e.cancelable) e.preventDefault();
                const pos = this.getEventPosition(e);
                const handleIndex = this.getHandleAt(pos);
                if (handleIndex !== null) {
                    this.isDragging = true;
                    this.draggedHandleIndex = handleIndex;
                }
            }

            onDragMove(e) {
                if (e.cancelable) e.preventDefault();
                if (!this.isDragging) return;
                const pos = this.getEventPosition(e);
                this.handles[this.draggedHandleIndex].x = Math.max(0, Math.min(pos.x, this.canvas.width - 1));
                this.handles[this.draggedHandleIndex].y = Math.max(0, Math.min(pos.y, this.canvas.height - 1));
                this.draw();
            }

            onDragEnd() { this.isDragging = false; }
            getCornerPoints() { return this.handles.map(h => [h.x, h.y]).flat(); }
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    ui.editorContainer.classList.remove('hidden');
                    ui.enhancementContainer.classList.add('hidden');
                    cropper = new PerspectiveCropper(ui.canvas, ui.ctx, img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function applyCrop() {
            if (!appReady || !cropper) return;
            loader.show('Applying crop...');
            
            setTimeout(() => {
                try {
                    const srcCanvas = ImageProcessor.imageToCanvas(cropper.image);
                    const [tl, tr, br, bl] = cropper.handles;
                    const width = Math.max(Math.hypot(br.x - bl.x, br.y - bl.y), Math.hypot(tr.x - tl.x, tr.y - tl.y));
                    const height = Math.max(Math.hypot(tr.x - br.x, tr.y - br.y), Math.hypot(tl.x - bl.x, tl.y - bl.y));
                    
                    const corners = cropper.getCornerPoints();
                    
                    if (originalCroppedCanvas) originalCroppedCanvas = null;
                    originalCroppedCanvas = ImageProcessor.perspectiveTransform(srcCanvas, corners, Math.round(width), Math.round(height));
                    
                    updatePreview(originalCroppedCanvas);
                    ui.enhancementContainer.classList.remove('hidden');
                    
                } catch (error) { 
                    console.error(error); 
                    alert("An error occurred during processing."); 
                } finally { 
                    loader.hide(); 
                }
            }, 50);
        }

        function updatePreview(canvas) {
            if (processedCanvas) processedCanvas = null;
            processedCanvas = ImageProcessor.createCanvas(canvas.width, canvas.height);
            const ctx = processedCanvas.getContext('2d');
            ctx.drawImage(canvas, 0, 0);
            
            const quality = parseFloat(ui.qualitySlider.value) / 100;
            const dataUrl = processedCanvas.toDataURL('image/jpeg', quality);
            ui.previewImage.src = dataUrl;
            ui.downloadLink.href = dataUrl;
        }

        function enhanceBAndW() {
            if (!originalCroppedCanvas) { alert("Please apply a crop first!"); return; }
            loader.show('Applying B&W enhancement...');

            setTimeout(() => {
                try {
                    let workingCanvas = originalCroppedCanvas;
                    
                    // Check if image is dark and needs inversion
                    const meanBrightness = ImageProcessor.calculateMean(workingCanvas);
                    if (meanBrightness < 120) {
                        workingCanvas = ImageProcessor.invert(workingCanvas);
                    }
                    
                    // Convert to grayscale
                    const grayCanvas = ImageProcessor.toGrayscale(workingCanvas);
                    
                    // Apply bilateral filter for noise reduction
                    const blurredCanvas = ImageProcessor.bilateralFilter(grayCanvas, 9, 75, 75);
                    
                    // Apply adaptive threshold for B&W effect
                    const enhancedCanvas = ImageProcessor.adaptiveThreshold(blurredCanvas, 15, 8);
                    
                    updatePreview(enhancedCanvas);
                } catch (err) { 
                    console.error("Error during enhancement: ", err); 
                } finally { 
                    loader.hide(); 
                }
            }, 50);
        }

        function enhanceGrayscale() {
            if (!originalCroppedCanvas) { alert("Please apply a crop first!"); return; }
            const grayCanvas = ImageProcessor.toGrayscale(originalCroppedCanvas);
            updatePreview(grayCanvas);
        }

        ui.fileInput.addEventListener('change', (e) => loadImage(e.target.files[0]));
        ui.cropButton.addEventListener('click', applyCrop);
        ui.enhanceButton.addEventListener('click', enhanceBAndW);
        ui.grayscaleButton.addEventListener('click', enhanceGrayscale);
        ui.originalColorButton.addEventListener('click', () => originalCroppedCanvas && updatePreview(originalCroppedCanvas));
        
        ui.qualitySlider.addEventListener('input', (e) => {
            ui.qualityValue.textContent = e.target.value;
            if (processedCanvas) updatePreview(processedCanvas);
        });

        ui.downloadLink.addEventListener('click', (e) => {
            if (!processedCanvas) {
                e.preventDefault();
                alert("Please process an image first.");
            } else {
                ui.downloadLink.download = `scanned-document-${Date.now()}.jpg`;
            }
        });

        loader.show('Initializing...');
        
        // Hide loader immediately since we don't need to load external libraries
        setTimeout(() => loader.hide(), 100);
    </script>
</body>
</html>
